
<!DOCTYPE html>
<html lang="zh-CN" class="loading">
<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>0x06 卷积神经网络 - 如是</title>
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="google" content="notranslate" />
    <meta name="keywords" content="Fechin,"> 
    <meta name="description" content="整体结构全连接的神经网络全连接的神经网络中，Affine层（仿射层，全连接层）后面跟着激活函数ReLU层或者Sigmoid层，相邻层的所有神经元之间都有连接。
卷积神经网络（CNN）CNN中新增了C,"> 
    <meta name="author" content="如是"> 
    <link rel="alternative" href="atom.xml" title="如是" type="application/atom+xml"> 
    <link rel="icon" href="/img/favicon.jpg"> 
    
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">

    
<link rel="stylesheet" href="/css/diaspora.css">

<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 5.4.0"></head>

<body class="loading">
    <span id="config-title" style="display:none">如是</span>
    <div id="loader"></div>
    <div id="single">
    <div id="top" style="display: block;">
    <div class="bar" style="width: 0;"></div>
    <a class="iconfont icon-home image-icon" href="javascript:;" data-url="http://example.com"></a>
    <div title="播放/暂停" class="iconfont icon-play"></div>
    <h3 class="subtitle">0x06 卷积神经网络</h3>
    <div class="social">
        <div>
            <div class="share">
                <a title="获取二维码" class="iconfont icon-scan" href="javascript:;"></a>
            </div>
            <div id="qr"></div>
        </div>
    </div>
    <div class="scrollbar"></div>
</div>

    <div class="section">
        <div class="article">
    <div class='main'>
        <h1 class="title">0x06 卷积神经网络</h1>
        <div class="stuff">
            <span>四月 05, 2021</span>
            
  <ul class="post-tags-list" itemprop="keywords"><li class="post-tags-list-item"><a class="post-tags-list-link" href="/tags/DL/" rel="tag">DL</a></li></ul>


        </div>
        <div class="content markdown">
            <h4 id="整体结构"><a href="#整体结构" class="headerlink" title="整体结构"></a>整体结构</h4><h5 id="全连接的神经网络"><a href="#全连接的神经网络" class="headerlink" title="全连接的神经网络"></a>全连接的神经网络</h5><p>全连接的神经网络中，Affine层（仿射层，全连接层）后面跟着激活函数ReLU层或者Sigmoid层，相邻层的所有神经元之间都有连接。<span id="more"></span></p>
<h5 id="卷积神经网络（CNN）"><a href="#卷积神经网络（CNN）" class="headerlink" title="卷积神经网络（CNN）"></a>卷积神经网络（CNN）</h5><p>CNN中新增了Convoluting层（卷积层）和Pooling层（池化层）。CNN的连接顺序是“Convoluting—ReLU—Pooling”，Pooling层有时会被省略。</p>
<p>在CNN中，有时将卷积层的输入输出数据成为特征图。</p>
<h4 id="卷积层"><a href="#卷积层" class="headerlink" title="卷积层"></a>卷积层</h4><h5 id="全连接层存在的问题"><a href="#全连接层存在的问题" class="headerlink" title="全连接层存在的问题"></a>全连接层存在的问题</h5><p>全连接层会忽视形状，将全部的输入数据作为相同的神经元（同一纬度的神经元，例如一般都会将多维数据拉平为一维数据）处理，无法利用与形状相关的信息。</p>
<h5 id="卷积运算"><a href="#卷积运算" class="headerlink" title="卷积运算"></a>卷积运算</h5><p>卷积层的处理就是进行卷积运算。</p>
<p>卷积运算对输入数据应用滤波器。对于输入数据，卷积运算以一定间隔滑动滤波器的窗口并应用。<strong>所谓的应用是指，将各个位置上滤波器的元素和输入的对应元素相乘，然后再求和（有时将这计算称为乘积累加运算）</strong>，然后将这个结果保存到输出对应的位置。在CNN中也存在偏置，偏置通常只有一个数据，这个值会被加到应用了滤波器的所有元素上。</p>
<h5 id="填充与步幅"><a href="#填充与步幅" class="headerlink" title="填充与步幅"></a>填充与步幅</h5><p>在进行卷积层的处理之前，有时要向输入数据的周围填入固定的数据，这称为填充，填充是为了调整输出的大小。</p>
<p>应用滤波器的位置间隔称为步幅。假设输入大小为（H， W），滤波器大小为（FH，FW），输出大小为（OH，OW），填充为P，步幅为S。输出大小可按下式计算：<br>$$<br>OH = \frac{H + 2P - FH}{S} +1  \\<br>OW = \frac{W + 2P - FW}{S} +1<br>$$</p>
<h5 id="多维数据的卷积运算"><a href="#多维数据的卷积运算" class="headerlink" title="多维数据的卷积运算"></a>多维数据的卷积运算</h5><p>输入数据和滤波器的通道数必须相同。通道方向上有多个特征图时，会按通道进行输入数据和滤波器的卷积运算，并将结果相加，从而得到输出。</p>
<p>使用多个滤波器可在通道方向上也拥有多个卷积运算的输出。<br>$$<br>(C, H, W) \ \bigotimes \ (FN, C, FH, FW) \ = \ (FN, FH, FW)<br>$$</p>
<p>通过应用FN个滤波器，输出特征图也生成了FN个。</p>
<p><img src="https://s2.ax1x.com/2019/07/23/eF8ejx.md.gif" alt="image"></p>
<h4 id="池化层"><a href="#池化层" class="headerlink" title="池化层"></a>池化层</h4><p>池化是缩小高、长方向上的空间的运算。例如：进行按2 x 2 的区域集约成1个元素的处理，缩小空间大小。一般来说，池化的窗口大小会和步幅设定成相同的值。Max池化是获取区域最大值的运算，图像识别领域主要使用Max池化，此外还有Average池化。</p>
<p>池化层的特征：</p>
<ul>
<li>没有要学习的参数</li>
<li>通道数不发生变化</li>
<li>对微小的位置变化具有鲁棒性<ul>
<li>输入数据发生微小偏差时，池化仍会返回相同的结果</li>
</ul>
</li>
</ul>
<h4 id="卷积层和池化层的实现"><a href="#卷积层和池化层的实现" class="headerlink" title="卷积层和池化层的实现"></a>卷积层和池化层的实现</h4><h5 id="基于im2col的展开"><a href="#基于im2col的展开" class="headerlink" title="基于im2col的展开"></a>基于im2col的展开</h5><p>im2col（image to column）是一个函数。</p>
<ul>
<li>对于输入数据，将其展开以适合滤波器的权重</li>
<li>对于滤波器，将其展开为一列</li>
</ul>
<p>im2col代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># image to column, 即从图像到矩阵函数，将数据转成二维矩阵以适合滤波器</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">im2col</span>(<span class="params">input_data, filter_h, filter_w, stride=<span class="number">1</span>, pad=<span class="number">0</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Parameters</span></span><br><span class="line"><span class="string">    ----------</span></span><br><span class="line"><span class="string">    input_data : 由(数据量, 通道, 高, 长)的4维数组构成的输入数据</span></span><br><span class="line"><span class="string">    filter_h : 滤波器的高</span></span><br><span class="line"><span class="string">    filter_w : 滤波器的长</span></span><br><span class="line"><span class="string">    stride : 步幅</span></span><br><span class="line"><span class="string">    pad : 填充</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Returns</span></span><br><span class="line"><span class="string">    -------</span></span><br><span class="line"><span class="string">    col : 2维数组</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    N, C, H, W = input_data.shape</span><br><span class="line">    out_h = (H + <span class="number">2</span>*pad - filter_h)//stride + <span class="number">1</span>  <span class="comment"># 计算输出的高度</span></span><br><span class="line">    out_w = (W + <span class="number">2</span>*pad - filter_w)//stride + <span class="number">1</span>  <span class="comment"># 计算输出的宽度</span></span><br><span class="line"></span><br><span class="line">    img = np.pad(input_data, [(<span class="number">0</span>,<span class="number">0</span>), (<span class="number">0</span>,<span class="number">0</span>), (pad, pad), (pad, pad)], <span class="string">&#x27;constant&#x27;</span>) <span class="comment"># 填充</span></span><br><span class="line">    col = np.zeros((N, C, filter_h, filter_w, out_h, out_w))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(filter_h):</span><br><span class="line">        y_max = y + stride*out_h</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(filter_w):</span><br><span class="line">            x_max = x + stride*out_w</span><br><span class="line">            col[:, :, y, x, :, :] = img[:, :, y:y_max:stride, x:x_max:stride]</span><br><span class="line"></span><br><span class="line">    col = col.transpose(<span class="number">0</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>).reshape(N*out_h*out_w, -<span class="number">1</span>) <span class="comment"># 将输出转为合适的形状</span></span><br><span class="line">    <span class="keyword">return</span> col</span><br></pre></td></tr></table></figure>

<p>输入数据的展开：</p>
<p><img src="https://s2.ax1x.com/2019/07/23/eF3v3n.png" alt="image"></p>
<p>对于滤波器：</p>
<p><img src="https://s2.ax1x.com/2019/07/23/eF89BT.png" alt="image"></p>
<h5 id="卷积层的实现"><a href="#卷积层的实现" class="headerlink" title="卷积层的实现"></a>卷积层的实现</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 卷积层的实现</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Convolution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, W, b, stride=<span class="number">1</span>, pad=<span class="number">0</span></span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        W: 权重</span></span><br><span class="line"><span class="string">        b：偏置</span></span><br><span class="line"><span class="string">        stride：步幅</span></span><br><span class="line"><span class="string">        pad：填充</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.W = W</span><br><span class="line">        self.b = b</span><br><span class="line">        self.stride = stride</span><br><span class="line">        self.pad = pad</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        x: 输入数据</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        FN, C, FH, FW = self.W.shape <span class="comment"># 权重的数量，通道数目，高，宽</span></span><br><span class="line">        N, C, H, W = x.shape <span class="comment"># 输入数据的数量，通道数目，高，宽</span></span><br><span class="line">        out_h = <span class="built_in">int</span>(<span class="number">1</span> + (H + <span class="number">2</span>*self.pad - FH) / self.stride)</span><br><span class="line">        out_w = <span class="built_in">int</span>(<span class="number">1</span> + (W + <span class="number">2</span>*self.pad - FW) / self.stride)</span><br><span class="line"></span><br><span class="line">        col = im2col(x, FH, FW, self.stride, self.pad) <span class="comment"># 将数据展开以适应滤波器</span></span><br><span class="line">        col_W = self.W.reshape(FN, -<span class="number">1</span>).T <span class="comment"># 滤波器的展开</span></span><br><span class="line">        </span><br><span class="line">        out = np.dot(col, col_W) + self.b</span><br><span class="line">        out = out.reshape(N, out_h, out_w, -<span class="number">1</span>).transpose(<span class="number">0</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>) <span class="comment"># 将输出大小转为合适的形状</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> out </span><br></pre></td></tr></table></figure>

<h5 id="池化层的实现"><a href="#池化层的实现" class="headerlink" title="池化层的实现"></a>池化层的实现</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 池化层的实现</span></span><br><span class="line"><span class="comment"># 池化层的展开与卷积层有不同之处，在于池化的应用区域按通道单独展开</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pooling</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, pool_h, pool_w, stride = <span class="number">1</span>, pad = <span class="number">0</span></span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        pool_h: 池化高度</span></span><br><span class="line"><span class="string">        pool_w: 池化宽度</span></span><br><span class="line"><span class="string">        stride: 步幅</span></span><br><span class="line"><span class="string">        pad: 填充</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.pool_h = pool_h</span><br><span class="line">        self.pool_w = pool_w</span><br><span class="line">        self.stride = stride</span><br><span class="line">        self.pad = pad</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        N, C, H, W = x.shape <span class="comment"># 输入数据的数量，通道数目，高度，宽度</span></span><br><span class="line">        out_h = <span class="built_in">int</span>(<span class="number">1</span> + (H - self.pool_h) / self.stride)</span><br><span class="line">        out_w = <span class="built_in">int</span>(<span class="number">1</span> + (W - self.pool_w) / self.stride)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 1. 展开输入数据</span></span><br><span class="line">        col = im2col(x, self.pool_h, self.pool_w, self.stride, self.pad)</span><br><span class="line">        col = col.reshape(-<span class="number">1</span>, self.pool_h * self.pool_w)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 2. 取各行的最大值， Max池化</span></span><br><span class="line">        out = np.<span class="built_in">max</span>(col, axis = <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 3. 转换为合适的输出大小, transpose 会更改多维数组的轴的顺序</span></span><br><span class="line">        out = out.reshape(N, out_h, out_w, C).transpose(<span class="number">0</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> out</span><br></pre></td></tr></table></figure>



<p>注：图片均来自网络</p>

            <!--[if lt IE 9]><script>document.createElement('audio');</script><![endif]-->
            <audio id="audio" loop="1" preload="auto" controls="controls" data-autoplay="false">
                <source type="audio/mpeg" src="">
            </audio>
            
                <ul id="audio-list" style="display:none">
                    
                        
                            <li title='0' data-url='http://link.hhtjim.com/163/425570952.mp3'></li>
                        
                    
                        
                            <li title='1' data-url='http://link.hhtjim.com/163/425570952.mp3'></li>
                        
                    
                </ul>
            
        </div>
        
    <div id='gitalk-container' class="comment link"
		data-enable='true'
        data-ae='false'
        data-ci=''
        data-cs=''
        data-r=''
        data-o=''
        data-a=''
        data-d='false'
    >查看评论</div>


    </div>
    
        <div class='side'>
			<ol class="toc"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B4%E4%BD%93%E7%BB%93%E6%9E%84"><span class="toc-number">1.</span> <span class="toc-text">整体结构</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%A8%E8%BF%9E%E6%8E%A5%E7%9A%84%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C"><span class="toc-number">1.1.</span> <span class="toc-text">全连接的神经网络</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%EF%BC%88CNN%EF%BC%89"><span class="toc-number">1.2.</span> <span class="toc-text">卷积神经网络（CNN）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%B7%E7%A7%AF%E5%B1%82"><span class="toc-number">2.</span> <span class="toc-text">卷积层</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%A8%E8%BF%9E%E6%8E%A5%E5%B1%82%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">2.1.</span> <span class="toc-text">全连接层存在的问题</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8D%B7%E7%A7%AF%E8%BF%90%E7%AE%97"><span class="toc-number">2.2.</span> <span class="toc-text">卷积运算</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A1%AB%E5%85%85%E4%B8%8E%E6%AD%A5%E5%B9%85"><span class="toc-number">2.3.</span> <span class="toc-text">填充与步幅</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%9A%E7%BB%B4%E6%95%B0%E6%8D%AE%E7%9A%84%E5%8D%B7%E7%A7%AF%E8%BF%90%E7%AE%97"><span class="toc-number">2.4.</span> <span class="toc-text">多维数据的卷积运算</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B1%A0%E5%8C%96%E5%B1%82"><span class="toc-number">3.</span> <span class="toc-text">池化层</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%B7%E7%A7%AF%E5%B1%82%E5%92%8C%E6%B1%A0%E5%8C%96%E5%B1%82%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.</span> <span class="toc-text">卷积层和池化层的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8Eim2col%E7%9A%84%E5%B1%95%E5%BC%80"><span class="toc-number">4.1.</span> <span class="toc-text">基于im2col的展开</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8D%B7%E7%A7%AF%E5%B1%82%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.2.</span> <span class="toc-text">卷积层的实现</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B1%A0%E5%8C%96%E5%B1%82%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.3.</span> <span class="toc-text">池化层的实现</span></a></li></ol></li></ol>	
        </div>
    
</div>


    </div>
</div>
</body>

<script src="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>


<script src="//lib.baomitu.com/jquery/1.8.3/jquery.min.js"></script>
<script src="/js/plugin.js"></script>
<script src="/js/typed.js"></script>
<script src="/js/diaspora.js"></script>


<link rel="stylesheet" href="/photoswipe/photoswipe.css">
<link rel="stylesheet" href="/photoswipe/default-skin/default-skin.css">


<script src="/photoswipe/photoswipe.min.js"></script>
<script src="/photoswipe/photoswipe-ui-default.min.js"></script>


<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">
    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>
    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">
        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>
        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">
            <div class="pswp__top-bar">
                <!--  Controls are self-explanatory. Order can be changed. -->
                <div class="pswp__counter"></div>
                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
                <button class="pswp__button pswp__button--share" title="Share"></button>
                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>
            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>
            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>
            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>
            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>
        </div>
    </div>
</div>



<script type="text/x-mathjax-config">
    MathJax.Hub.Config({"HTML-CSS": { preferredFont: "TeX", availableFonts: ["STIX","TeX"], linebreaks: { automatic:true }, EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50) },
        tex2jax: { inlineMath: [ ["$", "$"], ["\\(","\\)"] ], processEscapes: true, ignoreClass: "tex2jax_ignore|dno",skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']},
        TeX: {  noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } }, Macros: { href: "{}" } },
        messageStyle: "none"
    });
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>




</html>
